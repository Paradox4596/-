01_2_Hello_World (워터마크 있음)

프로그램:		컴퓨터에게 수행하게 하려는 작업
소스코드:		*.cpp, *.h와 같이 프로그래머가 작성한 텍스트파일
목적코드:		소스코드를 *.obj, *.o와 같이 해당 컴퓨터에 맞게 변환 한 것
컴파일:			소스코드를 목적코드로 바꾸는 과정
링크:				목적어들을 모두 연결하여 실행파일을 만들어 주는 과정
빌드:				IDE에서 컴파일과 링크를 합쳐서 부르는 말
라이브러리:		다른 사람이 작성한 코드, 프로그래밍을 쉽게 도와주는 프로그램의 집합
IDE:				VisualStudio, XCode등과 같은 프로그램, 편집기+컴파일러+링커의 도구 집합
함수:				여러개의 명령어를 가지고 있는 집합에 이름을 붙인 것. 반환 타입, 이름, 매개변수 목록, 본체 등의 요소를 가지고 있다.
에러:				컴퓨터 처리 시에 예상하지 못한 결과 또는 원하는 적절한 결과를 얻지 못하여 발생한 경우
main():			모든 프로그램이 가지고 있으며, 모든 프로그램의 시작지점 = Entry Point
솔루션:			*.sln과 같이 관련있는 여러 개의 프로젝트를 모아 한 번에 관리하는 파일 구조
프로젝트:		*.vcxproj와 같이 비주얼스튜디오에서 앱을 빌드 하기 위해 필요한 모든 아이템(소스코드, 아이콘, 이미지 등)을 모아둔 것

-----------------------------------------------------------------------------------------------------------------------------------------------------

02_1_객체_타입_값 (워터마크 있음)

ASCII:				미국정보교환표준부호(American Standard Code for Information Interchange)로 영문 알파벳을 사용하는 문자 인코딩
std::cout:			문자 출력 스트림
std::cin:			문자 입력 스트림
변수:				[객체에 이름을 붙여둔 것] / 값을 직접 집어넣고 꺼내는데 사용하는 객체
int:				4바이트 크기의 정수 타입
float:				4바이트 크기의 소수 타입
bool:				1바이트 크기의 참 거짓(1과 0)
char:				1바이트 크기의 문자 타입
overflow:			허용할 수 있는 값 이상으로 값을 증가시켰을 때 가장 작은 값으로 바뀌어 버리는 것
underflow:		허용할 수 있는 값 이하로 값을 감소시켰을 때 가장 큰 값으로 바뀌어 버리는 것
선언:				컴파일러가 참조할 식별자와 이름을 알리는 것. 중복되어도 문제없으며 두 번 이상 할 수 있음[객체의이름을 지정하는 구문]
정의:				식별자와 이름으로부터 코드를 생성하는 것. 프로그램에는 정의가 하나만 있어야 함[객체의 메모리 공간을 할당하는 일종의 선언]
초기화:			데이터 오브젝트나 변수의 초기 값 할당을 의미함
배정문:			프로그램에서 사용하는 여러 종류의 값들을 기억장소에 저장하기 위해 사용
Camel 표기법:	소문자로 시작하고 단어가 바뀌면 첫글자를 대문자로 표기
유니폼 초기화:	중괄호를 이용한 초기화..
lvalue:			연산자 좌측의 피연산자로 어떠한 이름을 가진 객체
rvalue:			연산자 우측의 피연산자로 어떠한 숫자의 값

-----------------------------------------------------------------------------------------------------------------------------------------------------

02_2_리터럴과_연산자 (워터마크 있음)

리터럴:			쓰여진 값 그대로 사용되는 값. 변수가 아닌 숫자들
Escape Sequence: 흐름을 벗어난다. 즉 일반적인 문자 표기법과 다른 형태를 가진 특수기호
산술 연산자:	정수 및 실수와 함께 사용될 때 사칙 연산을 수행하는 연산자
비트 연산자:	2진법(비트)에 대한 산술 연산(비트연산)을 수행하는 연산자
배정 연산자:	값을 때입한다는 의미로 사용되는 연산자. 일반 수항게서는 값의 같음을 비교하는데 사용하지만 쓰임처가 다르다.
증감 연산자:	변수의 앞 혹은 뒤에 사용하며 변수의 증가와 감소를 나타낸다. 배정문과 함께 사용할때 단일표현식이 앞 뒤냐에 따라 결과가 달라짐.
비교 연산자:	두 변수의 관계를 확인하는 연산자. 관계 연산자라고도 부름. 결과는 불린값이다
논리 연산자:	논리식을 판단하여 참 거짓을 반환하는 연산자

-----------------------------------------------------------------------------------------------------------------------------------------------------

02_3_컴퓨터개론 (워터마크 있음)

-2진수 변환-
15 => 1111(2)
127 => 1111111(2)
255 => 11111111(2)

-16진수 변환-
15 => F(0x)
127 => 7F(0x)
255 => FF(0x)

-----------------------------------------------------------------------------------------------------------------------------------------------------

03_1_구문과_흐름제어_1 (워터마크 있음)

인자:				키보드, 마우스등의 기본 입력 or 터치 스크린, 다른 프로그램, 프로그램 내부의 데이터 등의 다양한 입력들
자료구조:		입력을 처리하기 위해 필요한 다양한 데이터들을 묶어서 관리하는 것
표현식:			간단하게 식이라고도 부르며 하나 이상의 값으로 표현될 수 있는 코드
Lexicon:			어휘, 프로그램에서 문자로 쓰이는 것들
Syntax:			구문, 어휘의 조합..표현에 어울리는 구성
Semantic:		의미, 구문에서 만들어낸 맥락..? semantic error는 logical error라고도 한다. 프로그래머의 실수를 말함
if 구문:			조건식의 참과 거짓을 판별하여 ..
Flow Chart:		순서도라고도 하며 선택구문의 조건식에 의한 흐름을 도식화 한것
전치리기 지시문:	#include와 같이 컴파일 과정에서 가장 먼저 변환되어지며 <>안의 내용을 전부 가져와서 1번 라인에 포함시켜버리며 가장 앞에 #이 붙어있음
switch ~ case 구문: 조건식의 참 거짓 여부를 판단하여 분기하는 if구문과 다르게 값에 의해 분기하는 구문
레이블(Label):	소스 코드 안의 위치를 식별하는 일련의 문자열. ex) setich~case 구문에서 case등

-----------------------------------------------------------------------------------------------------------------------------------------------------

03_2_구문과_흐름제어_2 (워터마크 있음)

while 구문:			do ~while 구문과 비슷하지만 블럭 안의 내용이 무조건 한번은 실행하고 조건을 판단하는 do ~ while과 다르게 while문은 조건식 판단을 먼저 하고 반복한다.
do ~ while 구문:	조건식이 true일 동안에 표현식을 반복 수행하는 구문. 반복해서 증가하는 변수의 선언은 do {}블록 밖에 있다는 것에 주의.
for 구문:				초기화를 수행한 후 조건식을 비교하는 반복문. 초기화 / 연산으로 이뤄진 반복문은 while보다 더 유용하다
Local 변수:			중괄호 안에서 사용된 변수로, 지역 변수는 해당 중괄호 블록에서만 사용할 수 있게 된다.

-----------------------------------------------------------------------------------------------------------------------------------------------------

04_2_배열 (워터마크 있음)

암시적 변환:	정보 손실의 최소화 원칙에 따라 컴파일러가 타입을 자동적으로 변환 하는것. 표현 범위가 좁은 데이터 타입에서 -> 넓은 데이터 타입으로의 변환만 허용된다.
명시적 변환:	사용자가 직접 데이터의 타입을 변경하는 것. ()를 이용하여 묵시적 형변환과 다르게 표현 범위가 넓은 데이터 타입에서 좁은 데이터 타입으로의 변환 허용. 단! 데이터 값이 손실될 수 있다.
타입안정성:		타입의 규칙에 따라 객체를 이용하는것
축소변환:		저장공간이 큰 것을 작은 것으로 변환하는것. 값이 잘려나가며 프로그램에서 알수 없는 에러의 주범이 되기도함. ex)int(4 byte)->char(1 byte)
오버플로:    준비 된 공간을 넘쳐서 데이터를 집어 넣을 때 발생
열거형:			유한한 집합을 표현하기 위한 형식
구조체:			
배열:				동일한 형식의 값을 여러 개 저장할 경우에 사용할 수 있는 개념
문자열:
왼쪽값:			변수와 같은 저장할 수 있는 개체들. 한줄의 코드를 넘어 지속되는 특징을 가졌다. lvalue가 rvalue에 대입은 되지않는다.
오른쪽값:		리터럴, 상수, 연산식과 같이 현재 식 이외에는 유지되지 않는 임시 값들. rvalue를 lvalue에 대입 가능하다.

-----------------------------------------------------------------------------------------------------------------------------------------------------

05_2_재귀함수 (워터마크 있음)

함수 선언:			미리 어떤 함수가 있는지 알려주는 것. 함수 원형이라고도 한다. 위쪽에 선언한다.
함수 정의:			실제로 함수가 어떤 연산을 하는지 작성하는 곳. 
매개변수:			함수 정의에 열거된 이름(Callee)	
인자:					함수 호출에 넘겨줄 값(Caller)
값에 의한 호출:	함수를 홀출할 때 인자의 값이 매개변수로 복사되어 넘어가는 일.
함수 다형성:		매개변수 일치를 이용해서 함수가 다양한 형태를 가진것
지역 변수:			{} 블록 안에서 정의된 변수. 블록을 넘어가면 소멸된다.
전역 변수:			지역변수와 반대로 소스파일 어디에서도 사용할 수 있는 변수.
변수 범위:			
함수 오버로딩:		반환값과 이름이 같은 함수 
함수 시그니쳐:		함수의 이름, 매개변수의 타입, 개수, 순서등 함수의 특성을 나타내는 고유값
프로그램 진입점:	프로그램이 실행될 때 자동적으로 호출하는 main()함수. return을 명시하지 않아도 자동적으로 0을 반환하며 프로그램을 종료합니다.
재귀 함수:			함수 내부에서 자기 자신을 다시 호추랗는 함수.
스택:					새로 호출되는 것을 쌓고 반환하면 마지막에 저장된 것을 꺼내는 자료구조

-----------------------------------------------------------------------------------------------------------------------------------------------------

06_3_동적메모리관리 (워터마크 있음)

포인터(pointer):
참조에 의한 호출(call by Reference):
포인터 변수의 크기(size of pointer):
화살표 연산자(Arrow Operator):
참조형(Reference Type):
동적 메모리 할당(Dynamic Memory Allocation):
함수 포인터(Function Pointer):

-----------------------------------------------------------------------------------------------------------------------------------------------------

07_1_오류 (워터마크 있음)

예외: 예상 밖의 인자, 예상 밖의 입력, 잘못 된 계산
컴파일시간 오류: 컴파일러가 찾아낸 오류로 가장 수정하기 쉬운 것(문법 오류, 타입 오류 등)
실행시간 오류: 프로그램을 실행하는 동안 발생하는 오류로, 용의주도하고 꼼꼼한 프로그래머라면 그나마 수정하기 쉬움(컴퓨터,라이브러리,사용자 등이 감지한 오류)
링크시간 오류: 링커가 탐지한 오류로 역시 수정하기 쉽다. 주로 외부 라이브러리의 잘못된 사용으로 발생
exception: 오류에 대한 처리를 지원하는 기능(오류 발생, 예외 탐지 및 처리)
throw: 함수가 처리할 수 없는 오류가 발생하면 일반적인 return이 아닌 예외를 던짐
try: 
catch:
디버깅:

비주얼스튜디오 디버깅
중단점(F9)
프로시저 단위 실행(F10)
한 단계씩 코드 실행(F11)
:
